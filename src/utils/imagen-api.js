/**
 * Google Imagen 4 API Integration for Project Image Generation
 * 
 * This utility provides functions to generate photorealistic images
 * of window installation projects using Google's Imagen 4 model.
 */

const IMAGEN_API_KEY = 'AIzaSyAkBK20V5FrnFnTpz8e67SEomQ_HU-FNPM';
const IMAGEN_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/imagen-4:generateImage';

/**
 * Generate a single project image using Google Imagen 4
 * @param {string} prompt - The image generation prompt
 * @param {string} outputPath - Where to save the generated image (relative to public/)
 * @param {Object} options - Additional options for image generation
 * @returns {Promise<string>} - Path to the generated image
 */
export async function generateProjectImage(prompt, outputPath, options = {}) {
  const defaultOptions = {
    width: 1024,
    height: 768,
    quality: 'high',
    style: 'photorealistic',
    ...options
  };

  try {
    console.log(`üé® Generating image with prompt: ${prompt}`);
    
    const response = await fetch(IMAGEN_API_URL, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${IMAGEN_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        prompt: prompt,
        outputOptions: {
          mimeType: 'image/webp',
          compressionLevel: 0.8
        },
        generationConfig: {
          aspectRatio: `${defaultOptions.width}:${defaultOptions.height}`,
          negativePrompt: 'blurry, low quality, distorted, unrealistic, cartoon, anime, sketch',
          guidanceScale: 7.5,
          seed: Math.floor(Math.random() * 1000000)
        }
      })
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(`Imagen API error: ${response.status} - ${errorData.error?.message || 'Unknown error'}`);
    }

    const data = await response.json();
    
    if (!data.generatedImages || data.generatedImages.length === 0) {
      throw new Error('No images generated by Imagen API');
    }

    // Get the first generated image
    const generatedImage = data.generatedImages[0];
    const imageData = generatedImage.bytesBase64Encoded;
    
    // Convert base64 to buffer
    const imageBuffer = Buffer.from(imageData, 'base64');
    
    // Save to public directory
    const fs = await import('fs/promises');
    const path = await import('path');
    
    const fullOutputPath = path.join(process.cwd(), 'public', outputPath);
    const outputDir = path.dirname(fullOutputPath);
    
    // Ensure directory exists
    await fs.mkdir(outputDir, { recursive: true });
    
    // Write image file
    await fs.writeFile(fullOutputPath, imageBuffer);
    
    console.log(`‚úÖ Image saved to: ${outputPath}`);
    return outputPath;
    
  } catch (error) {
    console.error('‚ùå Error generating image:', error);
    
    // Return placeholder image path if generation fails
    const placeholderPath = '/images/windowsbishopsstortford-blogimages/dommoore_2018_mccarter_april_300dpi-3821-scaled_compressed-geotagged.webp';
    console.log(`üîÑ Using placeholder image: ${placeholderPath}`);
    return placeholderPath;
  }
}

/**
 * Generate before and after images for a project
 * @param {Object} project - Project data from projects.json
 * @returns {Promise<Object>} - Object with beforeImage and afterImage paths
 */
export async function generateProjectImages(project) {
  console.log(`üèóÔ∏è Generating images for project: ${project.title}`);
  
  // Generate "before" image prompt (older, worn windows)
  const beforePrompt = `Photorealistic exterior view of ${project.propertyType.toLowerCase()} in ${project.location.split(',')[0]} with old, worn, outdated windows that need replacement, showing signs of wear, paint peeling, condensation issues, British architecture, natural daylight, architectural photography style, high resolution`;
  
  // Use the project's optimized "after" prompt
  const afterPrompt = project.imagenPrompt;
  
  try {
    // Generate both images in parallel
    const [beforeImagePath, afterImagePath] = await Promise.all([
      generateProjectImage(
        beforePrompt, 
        `images/projects/${project.slug}-before.webp`,
        { seed: 12345 } // Fixed seed for consistency
      ),
      generateProjectImage(
        afterPrompt, 
        `images/projects/${project.slug}-after.webp`,
        { seed: 54321 } // Different seed for variety
      )
    ]);
    
    console.log(`‚úÖ Generated both images for ${project.title}`);
    
    return {
      beforeImage: beforeImagePath,
      afterImage: afterImagePath
    };
    
  } catch (error) {
    console.error(`‚ùå Error generating images for ${project.title}:`, error);
    
    // Return placeholder paths
    return {
      beforeImage: '/images/windowsbishopsstortford-blogimages/christmascottagewindowexternal_compressed-geotagged.webp',
      afterImage: '/images/windowsbishopsstortford-blogimages/dommoore_2018_mccarter_april_300dpi-3821-scaled_compressed-geotagged.webp'
    };
  }
}

/**
 * Generate images for all projects in the dataset
 * @param {Array} projects - Array of project objects
 * @param {Object} options - Generation options
 * @returns {Promise<Array>} - Updated projects with image paths
 */
export async function generateAllProjectImages(projects, options = {}) {
  const {
    batchSize = 2, // Process 2 projects at a time to respect rate limits
    delayBetweenBatches = 5000, // 5 second delay between batches
    skipExisting = true
  } = options;
  
  console.log(`üöÄ Starting batch image generation for ${projects.length} projects`);
  console.log(`üìä Batch size: ${batchSize}, Delay: ${delayBetweenBatches}ms`);
  
  const updatedProjects = [];
  
  // Process projects in batches
  for (let i = 0; i < projects.length; i += batchSize) {
    const batch = projects.slice(i, i + batchSize);
    console.log(`üîÑ Processing batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(projects.length / batchSize)}`);
    
    // Process current batch
    const batchPromises = batch.map(async (project) => {
      try {
        // Check if images already exist (if skipExisting is true)
        if (skipExisting) {
          const fs = await import('fs/promises');
          const path = await import('path');
          
          const beforePath = path.join(process.cwd(), 'public', `images/projects/${project.slug}-before.webp`);
          const afterPath = path.join(process.cwd(), 'public', `images/projects/${project.slug}-after.webp`);
          
          try {
            await fs.access(beforePath);
            await fs.access(afterPath);
            console.log(`‚è≠Ô∏è Images already exist for ${project.title}, skipping...`);
            return {
              ...project,
              beforeImage: `/images/projects/${project.slug}-before.webp`,
              afterImage: `/images/projects/${project.slug}-after.webp`
            };
          } catch {
            // Images don't exist, continue with generation
          }
        }
        
        const images = await generateProjectImages(project);
        return {
          ...project,
          ...images
        };
      } catch (error) {
        console.error(`‚ùå Failed to process project ${project.title}:`, error);
        return project; // Return original project if generation fails
      }
    });
    
    const batchResults = await Promise.all(batchPromises);
    updatedProjects.push(...batchResults);
    
    // Delay between batches (except for the last batch)
    if (i + batchSize < projects.length) {
      console.log(`‚è≥ Waiting ${delayBetweenBatches}ms before next batch...`);
      await new Promise(resolve => setTimeout(resolve, delayBetweenBatches));
    }
  }
  
  console.log(`üéâ Completed image generation for all projects`);
  return updatedProjects;
}

/**
 * Validate and optimize an image generation prompt
 * @param {string} prompt - The prompt to validate
 * @returns {string} - Optimized prompt
 */
export function optimizeImagePrompt(prompt) {
  // Add quality enhancers if not present
  const qualityTerms = ['photorealistic', 'high resolution', 'architectural photography'];
  const hasQualityTerms = qualityTerms.some(term => prompt.toLowerCase().includes(term.toLowerCase()));
  
  if (!hasQualityTerms) {
    prompt += ', photorealistic, high resolution, architectural photography style';
  }
  
  // Ensure British architecture context
  if (!prompt.toLowerCase().includes('british')) {
    prompt += ', British architecture';
  }
  
  // Add lighting if not specified
  if (!prompt.toLowerCase().includes('light')) {
    prompt += ', natural daylight';
  }
  
  return prompt.trim();
}

/**
 * Get API usage statistics (placeholder for future implementation)
 * @returns {Promise<Object>} - Usage statistics
 */
export async function getApiUsageStats() {
  // This would integrate with Google Cloud billing APIs in a real implementation
  return {
    imagesGenerated: 0,
    costEstimate: 0,
    remainingQuota: 'unlimited'
  };
}

/**
 * Test the Imagen API connection
 * @returns {Promise<boolean>} - True if API is accessible
 */
export async function testImagenConnection() {
  try {
    const testPrompt = 'A simple house with windows, photorealistic';
    const response = await fetch(IMAGEN_API_URL, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${IMAGEN_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        prompt: testPrompt,
        outputOptions: {
          mimeType: 'image/webp'
        }
      })
    });
    
    return response.ok;
  } catch (error) {
    console.error('‚ùå Imagen API connection test failed:', error);
    return false;
  }
}

// Export configuration for external use
export const IMAGEN_CONFIG = {
  apiKey: IMAGEN_API_KEY,
  apiUrl: IMAGEN_API_URL,
  defaultOptions: {
    width: 1024,
    height: 768,
    quality: 'high',
    format: 'webp'
  },
  rateLimits: {
    requestsPerMinute: 60,
    batchSize: 2,
    delayBetweenBatches: 5000
  }
};