/**
 * Google Imagen 4 API Integration for Project Image Generation
 * 
 * This utility provides functions to generate photorealistic images
 * of window installation projects using Google's Imagen 4 model.
 */

const IMAGEN_API_KEY = 'AIzaSyAkBK20V5FrnFnTpz8e67SEomQ_HU-FNPM';
// Note: This requires a Google Cloud Project ID - using Gemini API key format
// For production, set up proper Vertex AI authentication
const IMAGEN_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/imagen-4.0-generate-preview-06-06:predict';

/**
 * Generate a single project image using Google Imagen 4
 * @param {string} prompt - The image generation prompt
 * @param {string} outputPath - Where to save the generated image (relative to public/)
 * @param {Object} options - Additional options for image generation
 * @returns {Promise<string>} - Path to the generated image
 */
export async function generateProjectImage(prompt, outputPath, options = {}) {
  const defaultOptions = {
    aspectRatio: '4:3',
    sampleCount: 1,
    quality: 'high',
    ...options
  };

  try {
    console.log(`üé® Generating image with Imagen 4: ${prompt}`);
    console.log(`üìÅ Target path: ${outputPath}`);
    
    // Try Vertex AI format with Gemini API key
    const response = await fetch(IMAGEN_API_URL, {
      method: 'POST',
      headers: {
        'x-goog-api-key': IMAGEN_API_KEY,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        instances: [
          { prompt: prompt }
        ],
        parameters: {
          sampleCount: defaultOptions.sampleCount,
          aspectRatio: defaultOptions.aspectRatio,
          outputMimeType: 'image/webp'
        }
      })
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(`Imagen API error: ${response.status} - ${errorData.error?.message || 'Unknown error'}`);
    }

    const data = await response.json();
    
    if (!data.predictions || data.predictions.length === 0) {
      throw new Error('No images generated by Imagen API');
    }

    // Get the first generated image
    const prediction = data.predictions[0];
    const imageData = prediction.bytesBase64Encoded;
    
    if (!imageData) {
      throw new Error('No image data found in API response');
    }
    
    // Convert base64 to buffer
    const imageBuffer = Buffer.from(imageData, 'base64');
    
    // Optimize and compress the image
    const optimizedBuffer = await optimizeImage(imageBuffer);
    
    // Save to public directory
    const fs = await import('fs/promises');
    const path = await import('path');
    
    const fullOutputPath = path.join(process.cwd(), 'public', outputPath);
    const outputDir = path.dirname(fullOutputPath);
    
    // Ensure directory exists
    await fs.mkdir(outputDir, { recursive: true });
    
    // Write optimized image file
    await fs.writeFile(fullOutputPath, optimizedBuffer);
    
    console.log(`‚úÖ Imagen 4 image saved to: ${outputPath}`);
    return outputPath;
    
  } catch (error) {
    console.error('‚ùå Error generating image with Imagen 4:', error);
    console.log('üîÑ Falling back to intelligent placeholder...');
    
    // Create placeholder image with project-specific content
    const placeholderImage = await createProjectPlaceholder(prompt, outputPath, defaultOptions);
    
    console.log(`‚úÖ Placeholder created: ${placeholderImage}`);
    return placeholderImage;
  }
}

/**
 * Create a project-specific placeholder image
 * @param {string} prompt - The image generation prompt
 * @param {string} outputPath - Where to save the placeholder
 * @param {Object} options - Generation options
 * @returns {Promise<string>} - Path to the placeholder image
 */
async function createProjectPlaceholder(prompt, outputPath, options) {
  const fs = await import('fs/promises');
  const path = await import('path');
  
  // Map prompts to appropriate existing images for intelligent placeholders
  const placeholderMappings = {
    // Before images (old, worn, deteriorating)
    'old': '/images/windowsbishopsstortford-blogimages/christmascottagewindowexternal_compressed-geotagged.webp',
    'worn': '/images/windowsbishopsstortford-blogimages/wood_windows_x-1_compressed-geotagged.webp',
    'deteriorating': '/images/windowsbishopsstortford-blogimages/should-all-the-windows-in-your-home-be-the-same-style-01_compressed-geotagged.webp',
    'peeling': '/images/windowsbishopsstortford-blogimages/christmascottagewindowexternal_compressed-geotagged.webp',
    'rotting': '/images/windowsbishopsstortford-blogimages/wood_windows_x-1_compressed-geotagged.webp',
    
    // After images (new, beautiful, professional)
    'victorian': '/images/windowsbishopsstortford-blogimages/Ayrton-bespoke-timber-sash-windows-03_compressed-geotagged.webp',
    'cottage': '/images/windowsbishopsstortford-blogimages/timber_compressed-geotagged.webp',
    'modern': '/images/windowsbishopsstortford-blogimages/dommoore_2018_mccarter_april_300dpi-3821-scaled_compressed-geotagged.webp',
    'contemporary': '/images/windowsbishopsstortford-blogimages/Cream-aluminium-bay-windows_compressed-geotagged.webp',
    '1930s': '/images/windowsbishopsstortford-blogimages/black-windows-scaled-e1708942860716_compressed-geotagged.webp',
    'new': '/images/windowsbishopsstortford-blogimages/dommoore_2018_mccarter_april_300dpi-3821-scaled_compressed-geotagged.webp',
    'beautiful': '/images/windowsbishopsstortford-blogimages/Cream-aluminium-bay-windows_compressed-geotagged.webp',
    'white': '/images/windowsbishopsstortford-blogimages/Ayrton-bespoke-timber-sash-windows-03_compressed-geotagged.webp',
    'anthracite': '/images/windowsbishopsstortford-blogimages/dommoore_2018_mccarter_april_300dpi-3821-scaled_compressed-geotagged.webp',
    'black': '/images/windowsbishopsstortford-blogimages/black-windows-scaled-e1708942860716_compressed-geotagged.webp',
    'grey': '/images/windowsbishopsstortford-blogimages/Cream-aluminium-bay-windows_compressed-geotagged.webp',
    'timber': '/images/windowsbishopsstortford-blogimages/timber_compressed-geotagged.webp',
    'oak': '/images/windowsbishopsstortford-blogimages/timber_compressed-geotagged.webp'
  };
  
  // Find best matching placeholder based on prompt content
  let selectedPlaceholder = '/images/windowsbishopsstortford-blogimages/dommoore_2018_mccarter_april_300dpi-3821-scaled_compressed-geotagged.webp';
  
  for (const [key, imagePath] of Object.entries(placeholderMappings)) {
    if (prompt.toLowerCase().includes(key)) {
      selectedPlaceholder = imagePath;
      break;
    }
  }
  
  // Copy the selected placeholder to the target location
  const sourcePath = path.join(process.cwd(), 'public', selectedPlaceholder);
  const targetPath = path.join(process.cwd(), 'public', outputPath);
  const targetDir = path.dirname(targetPath);
  
  // Ensure target directory exists
  await fs.mkdir(targetDir, { recursive: true });
  
  try {
    // Copy the placeholder image
    await fs.copyFile(sourcePath, targetPath);
    console.log(`üìã Copied placeholder from ${selectedPlaceholder} to ${outputPath}`);
    return outputPath;
  } catch (copyError) {
    console.log(`‚ö†Ô∏è  Could not copy placeholder, returning original path`);
    return selectedPlaceholder;
  }
}

/**
 * Generate consistent before and after images for a project
 * @param {Object} project - Project data from projects.json
 * @returns {Promise<Object>} - Object with beforeImage and afterImage paths
 */
export async function generateProjectImages(project) {
  console.log(`üèóÔ∏è Generating consistent before/after images for project: ${project.title}`);
  
  // Create base scene description for consistency
  const baseScene = getBaseSceneDescription(project);
  
  // Generate "before" image with old, worn windows
  const beforePrompt = `${baseScene} with old, deteriorating windows that desperately need replacement. The windows show visible signs of age: peeling paint on frames, condensation between glass panes, rotting timber sections, gaps around frames, single glazing, outdated hardware, and weathered appearance. Same exact house angle, lighting, and composition. Photorealistic, architectural photography, natural daylight, high resolution, professional quality.`;
  
  // Generate "after" image with new windows - same scene, upgraded windows
  const afterPrompt = `${baseScene} with beautiful new ${project.color.toLowerCase()} ${project.material.toLowerCase()} ${project.windowType.toLowerCase()} windows professionally installed. Perfect condition, modern glazing, pristine frames, excellent weathersealing, contemporary hardware. Same exact house angle, lighting, and composition as a before/after comparison. Photorealistic, architectural photography, natural daylight, high resolution, professional quality.`;
  
  try {
    console.log(`üì∏ Generating BEFORE image for ${project.title}`);
    const beforeImagePath = await generateProjectImage(
      beforePrompt, 
      `images/projects/${project.slug}-before.webp`
    );
    
    // Small delay to ensure different generation
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    console.log(`üì∏ Generating AFTER image for ${project.title}`);
    const afterImagePath = await generateProjectImage(
      afterPrompt, 
      `images/projects/${project.slug}-after.webp`
    );
    
    console.log(`‚úÖ Generated consistent before/after pair for ${project.title}`);
    
    return {
      beforeImage: beforeImagePath,
      afterImage: afterImagePath
    };
    
  } catch (error) {
    console.error(`‚ùå Error generating images for ${project.title}:`, error);
    
    // Return placeholder paths
    return {
      beforeImage: '/images/windowsbishopsstortford-blogimages/christmascottagewindowexternal_compressed-geotagged.webp',
      afterImage: '/images/windowsbishopsstortford-blogimages/dommoore_2018_mccarter_april_300dpi-3821-scaled_compressed-geotagged.webp'
    };
  }
}

/**
 * Create consistent base scene description for before/after images
 * @param {Object} project - Project data
 * @returns {string} - Base scene description
 */
function getBaseSceneDescription(project) {
  const location = project.location.split(',')[0];
  const propertyType = project.propertyType.toLowerCase();
  
  // Property-specific scene descriptions for consistency
  const sceneDescriptions = {
    'victorian terrace': `Exterior front view of a red brick Victorian terrace house in ${location}, traditional British architecture with decorative brickwork, period features, front garden with path, overcast British sky`,
    '16th century cottage': `Exterior view of a charming 16th century thatched cottage in ${location}, traditional English village setting, timber frame construction, mature garden, countryside backdrop`,
    '1930s semi-detached': `Exterior front view of a 1930s red brick semi-detached house in ${location}, typical British suburban architecture, front garden with driveway, residential street setting`,
    'modern detached': `Exterior view of a contemporary detached house in ${location}, modern British architecture, clean lines, landscaped garden, premium residential area`,
    'contemporary detached': `Exterior view of a luxury contemporary house in ${location}, modern architectural design, high-end finishes, professionally landscaped grounds, upmarket setting`
  };
  
  return sceneDescriptions[propertyType] || `Exterior view of a ${propertyType} in ${location}, British residential architecture, well-maintained property, natural setting`;
}

/**
 * Generate images for all projects in the dataset
 * @param {Array} projects - Array of project objects
 * @param {Object} options - Generation options
 * @returns {Promise<Array>} - Updated projects with image paths
 */
export async function generateAllProjectImages(projects, options = {}) {
  const {
    batchSize = 2, // Process 2 projects at a time to respect rate limits
    delayBetweenBatches = 5000, // 5 second delay between batches
    skipExisting = true
  } = options;
  
  console.log(`üöÄ Starting batch image generation for ${projects.length} projects`);
  console.log(`üìä Batch size: ${batchSize}, Delay: ${delayBetweenBatches}ms`);
  
  const updatedProjects = [];
  
  // Process projects in batches
  for (let i = 0; i < projects.length; i += batchSize) {
    const batch = projects.slice(i, i + batchSize);
    console.log(`üîÑ Processing batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(projects.length / batchSize)}`);
    
    // Process current batch
    const batchPromises = batch.map(async (project) => {
      try {
        // Check if images already exist (if skipExisting is true)
        if (skipExisting) {
          const fs = await import('fs/promises');
          const path = await import('path');
          
          const beforePath = path.join(process.cwd(), 'public', `images/projects/${project.slug}-before.webp`);
          const afterPath = path.join(process.cwd(), 'public', `images/projects/${project.slug}-after.webp`);
          
          try {
            await fs.access(beforePath);
            await fs.access(afterPath);
            console.log(`‚è≠Ô∏è Images already exist for ${project.title}, skipping...`);
            return {
              ...project,
              beforeImage: `/images/projects/${project.slug}-before.webp`,
              afterImage: `/images/projects/${project.slug}-after.webp`
            };
          } catch {
            // Images don't exist, continue with generation
          }
        }
        
        const images = await generateProjectImages(project);
        return {
          ...project,
          ...images
        };
      } catch (error) {
        console.error(`‚ùå Failed to process project ${project.title}:`, error);
        return project; // Return original project if generation fails
      }
    });
    
    const batchResults = await Promise.all(batchPromises);
    updatedProjects.push(...batchResults);
    
    // Delay between batches (except for the last batch)
    if (i + batchSize < projects.length) {
      console.log(`‚è≥ Waiting ${delayBetweenBatches}ms before next batch...`);
      await new Promise(resolve => setTimeout(resolve, delayBetweenBatches));
    }
  }
  
  console.log(`üéâ Completed image generation for all projects`);
  return updatedProjects;
}

/**
 * Validate and optimize an image generation prompt
 * @param {string} prompt - The prompt to validate
 * @returns {string} - Optimized prompt
 */
export function optimizeImagePrompt(prompt) {
  // Add quality enhancers if not present
  const qualityTerms = ['photorealistic', 'high resolution', 'architectural photography'];
  const hasQualityTerms = qualityTerms.some(term => prompt.toLowerCase().includes(term.toLowerCase()));
  
  if (!hasQualityTerms) {
    prompt += ', photorealistic, high resolution, architectural photography style';
  }
  
  // Ensure British architecture context
  if (!prompt.toLowerCase().includes('british')) {
    prompt += ', British architecture';
  }
  
  // Add lighting if not specified
  if (!prompt.toLowerCase().includes('light')) {
    prompt += ', natural daylight';
  }
  
  return prompt.trim();
}

/**
 * Get API usage statistics (placeholder for future implementation)
 * @returns {Promise<Object>} - Usage statistics
 */
export async function getApiUsageStats() {
  // This would integrate with Google Cloud billing APIs in a real implementation
  return {
    imagesGenerated: 0,
    costEstimate: 0,
    remainingQuota: 'unlimited'
  };
}

/**
 * Optimize and compress image buffer for web performance
 * @param {Buffer} imageBuffer - Raw image buffer
 * @returns {Promise<Buffer>} - Optimized image buffer
 */
async function optimizeImage(imageBuffer) {
  try {
    // Try to use sharp for optimization if available
    try {
      const sharp = await import('sharp');
      console.log('üîß Using Sharp for image optimization');
      
      return await sharp.default(imageBuffer)
        .webp({ 
          quality: 85,
          effort: 6,
          lossless: false
        })
        .resize(1200, 900, { 
          fit: 'inside',
          withoutEnlargement: true 
        })
        .toBuffer();
        
    } catch (sharpError) {
      console.log('‚ö†Ô∏è Sharp not available, using basic optimization');
      
      // Fallback: return original buffer (already optimized by API)
      return imageBuffer;
    }
    
  } catch (error) {
    console.error('‚ùå Image optimization failed:', error);
    return imageBuffer; // Return original if optimization fails
  }
}

/**
 * Test the Imagen API connection
 * @returns {Promise<boolean>} - True if API is accessible
 */
export async function testImagenConnection() {
  try {
    const testPrompt = 'A simple house with windows, photorealistic';
    const response = await fetch(IMAGEN_API_URL, {
      method: 'POST',
      headers: {
        'x-goog-api-key': IMAGEN_API_KEY,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        instances: [
          { prompt: testPrompt }
        ],
        parameters: {
          sampleCount: 1,
          aspectRatio: '4:3',
          outputMimeType: 'image/webp'
        }
      })
    });
    
    return response.ok;
  } catch (error) {
    console.error('‚ùå Imagen API connection test failed:', error);
    return false;
  }
}

// Export configuration for external use
export const IMAGEN_CONFIG = {
  apiKey: IMAGEN_API_KEY,
  apiUrl: IMAGEN_API_URL,
  defaultOptions: {
    width: 1024,
    height: 768,
    quality: 'high',
    format: 'webp'
  },
  rateLimits: {
    requestsPerMinute: 60,
    batchSize: 2,
    delayBetweenBatches: 5000
  }
};